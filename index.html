<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="normalize.css" />

    <link rel="stylesheet" type="text/css" href="prettify.css" />
    <script src="prettify.js"></script>

    <link rel="stylesheet" type="text/css" href="index.css" />
  </head>

  <body onload="prettyPrint();">

    <h1>Javascript Coroutines and Event Handling</h1>

    <p>Javascript 1.7 adds support for Python-style generators and coroutines, using the <code>yield</code> keyword.</p>
    <p>Javascript makes extensive use of callbacks, which make Javascript coroutines particularly interesting because they can be used to 'invert' multiple callbacks into a single imperative event loop.</p>

    <h2>For Example: A Draggable Div</h2>

    <p>Below are two implementations of a draggable div, one using standard Javascript callbacks, the other using a coroutine event loop.</p>
    <p>Comparing the code side-by-side, you can see the structural difference between multiple callbacks and a single event loop.</p>

    <div class="figure left">
      <p>draggable div using callbacks:</p>
      <p><iframe src="test.html" width="400px" height="400px"></iframe></p>
      <pre class="prettyprint">
var dragging = false;
function onmousedown(event) {
    dragging = true;
}
function onmousemove(event) {
    if (dragging)
        move(event);
}
function onmouseup(event) {
    dragging = false;
}

// register the listeners:
$('#box').mousedown(onmousedown);
$(window).mousemove(onmousemove)
    .mouseup(onmouseup);
      </pre>
    </div>

    <div class="figure left">
      <p>draggable div using a coroutine event loop: (Firefox only)</p>
      <p><iframe src="test-yield.html" width="400px" height="400px"></iframe></p>
      <pre class="prettyprint">
function loop() {
    var event;
    while (event = (yield)) {
        if (event.type == 'mousedown') {
            while (event = (yield)) {
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
}

// register the listeners:
var handler = loop(); handler.next();
function send(event) {
    handler.send(event);
}
$('#box').mousedown(send);
$(window).mousemove(send).mouseup(send);
      </pre>
    </div>

    <h3 class="clear">Notes</h2>
    <ul>
      <li><code>move(event)</code> is defined elsewhere and simply moves the div.</li>
      <li><p><code class="prettyprint">while (event = (yield)) { ... }</code>
        is equivalent to:</p>
        <p><code class="prettyprint">while (true) { event = (yield); ... }</code>
        since we will never send anything 'falsey' to the coroutine.</p>
        <p>This just makes for more concise event loop syntax, in my opinion.</p></li>
    </ul>

    <h2>How It Works</h2>

    <p><code>loop()</code> is always in one of two states, depending on which <code>yield</code> it is blocked on:</p>
    <ol>
      <li>At the outer <code>yield</code> it loops through events until it receives a mousedown, at which point it enters the inner loop.</li>
      <li>Then it moves to the inner <code>yield</code>, where it processes mousemoves until it receives a mouseup, at which point it breaks back to the outer loop.</li>
    </ol>

    <p>We register event listeners that send events to <code>loop()</code> such that the <code>yield</code> statements returns events as they happen:</p>
    <ol>
      <li>We instantiate the coroutine with <code class="prettyprint">var handler = loop();</code></li>
      <li>We call <code class="prettyprint">handler.next();</code> to 'prime' the coroutine by running it until it blocks on the first <code>yield</code>.</li>
      <li>We define the <code>send</code> function which simply sends its argument to the coroutine, and is thus the perfect function to register as a callback on all the events we wish to be sent to the coroutine.</li>
    </ol>
    <p>So now each event we are listening to is sent to the coroutine, and it resumes at whichever <code>yield</code> it is blocked on, with the sent event being returned as the value of <code>yield</code>.</p>

    <h2>Explicit And Implicit State</h2>
    <div class="figure right">
      <img src="dragging.svg">
      <p>the dragging state machine</p>
    </div>

    <p>Both approaches implement the same state machine, using completely different mechanisms:</p>
    <p>In the callback approach, the state is stored explicitly in the <code>dragging</code> variable, with the two states corresponding to <code>dragging==false</code> and <code>dragging==true</code>.</p>
    <p>In the coroutine approach, the state is stored implicitly, in terms of which <code>yield</code> the coroutine is currently blocked on, with the not-dragging state corresponding to the outer <code>yield</code> and the dragging state corresponding to the inner <code>yield</code>.</p>

    <div class="clear credits">Harold Cooper, November 2012</div>

  </body>
</html>
